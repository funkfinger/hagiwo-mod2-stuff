/*
HAGIWO MOD2 Sample Player Ver1.0

  • It is possible to save audio files up to a total of 20 seconds / 8 files.
  • One-shot digital sample playback: plays 16-bit PCM samples stored in flash
  • 8 samples selectable via two-stage selection: group (A1) and sub-index (A2)
  • Playback speed control (A0): 0.5× to 1.5× speed with linear interpolation
anti-aliasing • Trigger inputs (GPIO7 rising-edge, GPIO6 falling-edge) start
playback • Trigger LED indicator (GPIO5): lights for 20 ms on trigger • PWM
audio output (GPIO1) at ~36.6 kHz using 10-bit resolution

  --Pin assign---
POT1     A0       Playback speed control (0.5×–1.5×)
POT2     A1       Sample group select (1–4, 5–8)
POT3     A2       Sample index select within group
IN1      GPIO7    External trigger (rising-edge)
IN2      GPIO0    select +4 sample number
CV       A2       Shared with POT3
BUTTON   GPIO6    Manual trigger (active-low, pull-up)
OUT      GPIO1    10-bit PWM audio output (~36.6 kHz)
LED      GPIO17   Trigger LED indicator (20 ms pulse) - RP2040 built-in LED
LED_EXT  GPIO5    External LED indicator (20 ms pulse)
EEPROM   N/A

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial
purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or
contain incorrect comments.
*/

#include <Arduino.h>

#include "hardware/irq.h"
#include "hardware/pwm.h"
#include "samples/samples.h"  // Header file containing sample data arrays

#define FRAC_BITS 12
#define FRAC_MASK ((1UL << FRAC_BITS) - 1)

const uint16_t PWM_FS = 1023;
const uint16_t PWM_MID = PWM_FS / 2;
const uint16_t PWM_WRAP = 4095;

volatile bool playing = false;
volatile uint32_t tblAcc = 0;
volatile uint32_t tblStepFP = 1UL << FRAC_BITS;
volatile const uint8_t* curSample = samples[0];
volatile uint32_t curLen16 = sample_lengths[0];

uint sliceAudio, sliceIRQ;

volatile bool ledOn = false;
uint32_t ledOnTime = 0;

inline int16_t readPCM(const volatile uint8_t* base, uint32_t idx) {
  uint32_t byteIndex = idx << 1;
  return int16_t(base[byteIndex] | (base[byteIndex + 1] << 8));
}

void on_pwm_wrap() {
  pwm_clear_irq(sliceIRQ);

  if (!playing) {
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, PWM_MID);
    return;
  }

  uint32_t idx = tblAcc >> FRAC_BITS;
  uint32_t frac = tblAcc & FRAC_MASK;

  if (idx >= curLen16) {
    playing = false;
    tblAcc = 0;
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, PWM_MID);
    return;
  }

  int16_t s1 = readPCM(curSample, idx);
  int16_t s2 = (idx + 1 < curLen16) ? readPCM(curSample, idx + 1) : 0;
  int32_t mix =
      ((int32_t)s1 * ((1UL << FRAC_BITS) - frac) + (int32_t)s2 * frac) >>
      FRAC_BITS;
  int16_t interpolated = int16_t(mix);

  uint16_t pwmVal = uint16_t(int32_t(interpolated) + 32768) >> 6;
  pwm_set_chan_level(sliceAudio, PWM_CHAN_B, pwmVal);

  tblAcc += tblStepFP;
}

uint8_t selectSampleIndex() {
  uint16_t groupVal = analogRead(A1);

  uint8_t group;
  if (groupVal <= 341)
    group = 0;  // Samples 0-3
  else if (groupVal <= 684)
    group = 1;  // Samples 4-7
  else
    group = 0;  // Default to first group if out of range

  uint16_t val = 1023 - analogRead(A2);
  uint8_t subIndex;
  if (val < 256)
    subIndex = 0;
  else if (val < 512)
    subIndex = 1;
  else if (val < 768)
    subIndex = 2;
  else
    subIndex = 3;

  uint8_t index = group * 4 + subIndex;

  // Ensure index is within valid range (0-7)
  if (index >= NUM_SAMPLES) {
    index = index % NUM_SAMPLES;
  }

  return index;
}

void onTrigger() {
  playing = false;
  tblAcc = 0;

  delay(5);

  uint8_t idx = selectSampleIndex();
  curSample = samples[idx];
  curLen16 = sample_lengths[idx];

  uint16_t raw = analogRead(A0);
  float rate = 0.5f + (raw / 1023.0f);
  tblStepFP = uint32_t(rate * float(1 << FRAC_BITS));

  digitalWrite(17, HIGH);  // Built-in LED
  digitalWrite(5, HIGH);   // External LED
  ledOn = true;
  ledOnTime = millis();

  playing = true;
}

void setup() {
  analogReadResolution(10);

  pinMode(0, INPUT);
  pinMode(17, OUTPUT);  // RP2040 built-in LED
  digitalWrite(17, LOW);
  pinMode(5, OUTPUT);  // External LED
  digitalWrite(5, LOW);

  pinMode(1, OUTPUT);
  gpio_set_function(1, GPIO_FUNC_PWM);
  pinMode(2, OUTPUT);
  gpio_set_function(2, GPIO_FUNC_PWM);
  sliceAudio = pwm_gpio_to_slice_num(1);
  sliceIRQ = pwm_gpio_to_slice_num(2);

  pwm_set_clkdiv(sliceAudio, 1);
  pwm_set_wrap(sliceAudio, PWM_FS);
  pwm_set_enabled(sliceAudio, true);

  pwm_set_clkdiv(sliceIRQ, 1);
  pwm_set_wrap(sliceIRQ, PWM_WRAP);
  pwm_set_enabled(sliceIRQ, true);
  pwm_clear_irq(sliceIRQ);
  pwm_set_irq_enabled(sliceIRQ, true);
  irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
  irq_set_enabled(PWM_IRQ_WRAP, true);

  pinMode(7, INPUT);
  attachInterrupt(digitalPinToInterrupt(7), onTrigger, RISING);
  pinMode(6, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(6), onTrigger, FALLING);
}

void loop() {
  if (ledOn && (millis() - ledOnTime >= 20)) {
    digitalWrite(17, LOW);  // Built-in LED
    digitalWrite(5, LOW);   // External LED
    ledOn = false;
  }
}
